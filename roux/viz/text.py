# AUTOGENERATED! DO NOT EDIT! File to edit: ../../examples/roux_viz_text.ipynb.

# %% auto 0
__all__ = ['set_text_multicolored']

# %% ../../examples/roux_viz_text.ipynb 2
"""text of plotting functions."""

import matplotlib.pyplot as plt
from matplotlib.colors import to_rgba
from matplotlib.text import Text
def set_text_multicolored(
    x: float = None,
    y: float = None,
    s: str = None,
    
    sep: str = None,    
    rsplit=False,
    
    color: any = None,
    color2_alpha=0.5,
    
    ha='center',
    ax=None,
    **kwargs
):
    """
    Plots a string split into two parts with different color.

    The string is split by the separator `sep`. If `color` is a single
    color string, the second part of the text is drawn with 50% alpha.

    Args:
        x (float): The horizontal coordinate for the text.
        y (float): The vertical coordinate for the text anchor point.
        s (str): The string to plot, containing the separator.
        sep (str): The separator to split the string by (e.g., '\\n').
        color (any, optional): A list/tuple of two color, or a single
                                color string. Defaults to ['black', 'gray'].
        ax (plt.Axes, optional): The axes to plot on. If None, uses plt.gca().
        **kwargs: Additional keyword arguments passed to both ax.text calls
                  (e.g., ha, fontsize).
    """
    if isinstance(s,Text):
        text_obj=s
        del s
        # 1. Extract properties from the existing text object
        ax = text_obj.axes
        s = text_obj.get_text()
        x, y = text_obj.get_position()
        
        # Extract original text properties to pass them along
        text_props = {
                'color' : text_obj.get_color(),
                'ha': text_obj.get_ha(),
                'fontsize': text_obj.get_fontsize(),
                'fontweight': text_obj.get_fontweight(),
            }
        kwargs={
            **text_props,
            **{
                **dict(
                    sep=sep, #: str = None,    
                    rsplit=rsplit, #=False,
                    
                    color=color, #: any = None,
                    color2_alpha=color2_alpha, #=0.5,
                    
                    ha=ha, #='center',
                    ),
                **kwargs,
            },
        }
        # # Update with any new kwargs the user provides
        # text_props.update(kwargs)
    
        # 2. Remove the original text object from the axes
        text_obj.remove()
    
        # 3. Call the drawing function to replace it
        return set_text_multicolored(
            x=x,
            y=y,
            s=s,
            ax=ax,
            **kwargs
        )
        
    if ax is None:
        ax = plt.gca()

    # --- Modification: Handle the color argument dynamically ---
    if color is None:
        color = 'black'
    if isinstance(color, str):
        # If a single color string is given, use it for the first part
        # and a semi-transparent version for the second.
        color1 = color
        rgba = to_rgba(color)
        color2 = (rgba[0], rgba[1], rgba[2], color2_alpha) # Set alpha to 0.5
    else:
        # Assume color is a list or tuple of two color
        color1, color2 = color[0], color[1]
    # --- End Modification ---

    # Split the input text into two parts
    if sep is None:
        if '\n' in s:
            sep='\n'
            
    if not rsplit:
        parts = s.split(sep, 1)
    else:
        parts = s.rsplit(sep, 1)
        
    string_part1 = parts[0]
    string_part2 = parts[1] if len(parts) > 1 else ""

    # Set default horizontal alignment if not provided
    # kwargs.setdefault('ha', 'center')

    # 1. Plot the first part, aligned by its bottom edge
    ax.text(
        x,
        y,
        string_part1,
        **{
            **dict(
                va='bottom' if sep =='\n' else 'center',
                ha=ha if sep =='\n' else 'right',
                color=color1,
            ),
            **kwargs,
        }
       )

    # 2. Plot the second part, aligned by its top edge
    ax.text(
        x,
        y,
        string_part2,
        **{
            **dict(
                va='top' if sep =='\n' else 'center',
                ha=ha if sep =='\n' else 'left',
                color=color2,
            ),
            **kwargs,
        }
        )

    return ax
