# AUTOGENERATED! DO NOT EDIT! File to edit: ../../examples/roux_workflow_pms.ipynb.

# %% auto 0
__all__ = ['extract_pms', 'read_pms']

# %% ../../examples/roux_workflow_pms.ipynb 2
import ast
import re

def _code_string_to_dict(code_string):
    """
    Converts a string containing Python assignment statements into a dictionary.
    
    Args:
        code_string (str): String containing Python assignment statements.
    
    Returns:
        dict: Dictionary mapping variable names to their values.
    """
    result = {}
    
    # Remove comments (lines starting with #) but preserve inline comments in values
    lines = code_string.strip().split('\n')
    cleaned_lines = []
    
    for line in lines:
        # Remove full-line comments
        if line.strip().startswith('#'):
            continue
        
        # Remove inline comments (but not inside strings)
        # Find first # that's not inside quotes
        in_single_quote = in_double_quote = False
        for i, char in enumerate(line):
            if char == "'" and not in_double_quote and (i == 0 or line[i-1] != '\\'):
                in_single_quote = not in_single_quote
            elif char == '"' and not in_single_quote and (i == 0 or line[i-1] != '\\'):
                in_double_quote = not in_double_quote
            elif char == '#' and not in_single_quote and not in_double_quote:
                line = line[:i]
                break
        
        cleaned_lines.append(line)
    
    # Join cleaned lines and split into statements
    code = '\n'.join(cleaned_lines)
    
    # Parse the code with ast
    try:
        tree = ast.parse(code)
    except SyntaxError:
        # If parsing fails, try to extract assignments manually
        return _fallback_extract_assignments(code_string)
    
    # Execute in a safe namespace
    namespace = {}
    
    # Define safe globals (only safe builtins)
    safe_globals = {
        'None': None,
        'True': True,
        'False': False,
        'dict': dict,
        'list': list,
        'tuple': tuple,
    }
    
    # Execute each assignment statement
    for node in ast.walk(tree):
        if isinstance(node, ast.Assign):
            # Get the target variable name(s)
            for target in node.targets:
                if isinstance(target, ast.Name):
                    # Evaluate the value
                    try:
                        # Compile and evaluate the expression
                        expr = ast.Expression(node.value)
                        code_obj = compile(expr, '<string>', 'eval')
                        value = eval(code_obj, {**safe_globals, **namespace}, {})
                        
                        # Store in both result dict and namespace for subsequent references
                        result[target.id] = value
                        namespace[target.id] = value
                    except:
                        # If evaluation fails, try to get the literal string
                        try:
                            value = ast.literal_eval(node.value)
                            result[target.id] = value
                            namespace[target.id] = value
                        except:
                            # Last resort: get the source as string
                            result[target.id] = ast.unparse(node.value) if hasattr(ast, 'unparse') else str(node.value)
    
    return result


def _fallback_extract_assignments(code_string):
    """
    Fallback method using regex for simple cases when ast parsing fails.
    """
    result = {}
    
    # Pattern to match variable assignments
    pattern = r'^([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)$'
    
    lines = code_string.strip().split('\n')
    current_var = None
    current_value_lines = []
    
    for line in lines:
        line = line.strip()
        
        # Skip comment lines
        if line.startswith('#'):
            continue
        
        # Remove inline comments
        if '#' in line:
            # Check if # is inside quotes
            in_quotes = False
            quote_char = None
            for i, char in enumerate(line):
                if char in ('"', "'"):
                    if not in_quotes:
                        in_quotes = True
                        quote_char = char
                    elif quote_char == char and (i == 0 or line[i-1] != '\\'):
                        in_quotes = False
                elif char == '#' and not in_quotes:
                    line = line[:i]
                    break
        
        # Check for variable assignment
        match = re.match(pattern, line)
        if match:
            # Save previous variable if exists
            if current_var is not None:
                value_str = '\n'.join(current_value_lines)
                try:
                    result[current_var] = ast.literal_eval(value_str)
                except:
                    result[current_var] = value_str
            
            # Start new variable
            current_var = match.group(1)
            current_value_lines = [match.group(2)]
        elif current_var is not None:
            # Continuation of multi-line value
            current_value_lines.append(line)
    
    # Save the last variable
    if current_var is not None:
        value_str = '\n'.join(current_value_lines)
        try:
            result[current_var] = ast.literal_eval(value_str)
        except:
            result[current_var] = value_str
    
    return result


def extract_pms(lines, fmt='dict'):
    """
    Extract keyword arguments from lines of code.
    
    Args:
        lines (str or list): String or list of strings containing assignment statements
        fmt (str): Output format - 'dict' for dictionary or 'list' for list of "key=value" strings
    
    Returns:
        dict or list: Depending on fmt parameter
    """
    # Convert lines to string if it's a list
    if isinstance(lines, list):
        code_string = '\n'.join(lines)
    else:
        code_string = lines
    
    # Use code_string_to_dict to parse the code
    params_dict = _code_string_to_dict(code_string)
    
    if fmt == 'dict':
        return params_dict
    else:
        # Convert to list of "key=value" strings
        parameters = []
        for key, value in params_dict.items():
            # Determine if value needs quotes
            if isinstance(value, str):
                # Check if it's already a string literal representation
                try:
                    # Try to see if it can be evaluated as a literal
                    ast.literal_eval(value)
                    # If it succeeds, it's a Python literal, keep as is
                    parameters.append(f"{key}={value}")
                except:
                    # If it fails, it's a regular string, add quotes
                    parameters.append(f"{key}='{value}'")
            else:
                # For non-strings, use repr() to get proper Python representation
                parameters.append(f"{key}={repr(value)}")
        return parameters

## I/O
import nbformat

def read_pms(notebook_path, tag='parameters'):
    """
    Extract code from cells tagged with 'parameters' in a Jupyter notebook.
    
    Args:
        notebook_path (str): Path to the .ipynb file
        tag (str): The tag to look for (default: 'parameters')
    
    Returns:
        list: List of code strings from tagged cells
    """
    # Read the notebook
    with open(notebook_path, 'r', encoding='utf-8') as f:
        notebook = nbformat.read(f, as_version=4)
        
    # Iterate through cells
    for cell in notebook.cells:
        if cell.cell_type == 'code':
            # Check if the cell has the specified tag
            cell_tags = cell.metadata.get('tags', [])
            if tag in cell_tags:
                # parameters_code.append()
                pms_str=cell.source
                break
                
    return extract_pms(pms_str)
